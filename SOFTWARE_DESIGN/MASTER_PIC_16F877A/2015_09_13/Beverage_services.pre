
# 1 "F:\BEVERAGES_ENHANCEMENT\SOFTWARE_DESIGN\MASTER_PIC_16F877A\2015_09_13\Beverage_services.c"

# 82 "C:\Program Files\HI-TECH Software\PICC\9.82\include\pic16f877a.h"
volatile unsigned char INDF @ 0x000;



volatile unsigned char TMR0 @ 0x001;



volatile unsigned char PCL @ 0x002;



volatile unsigned char STATUS @ 0x003;

volatile bit CARRY @ ((unsigned)&STATUS*8)+0;
volatile bit DC @ ((unsigned)&STATUS*8)+1;
volatile bit ZERO @ ((unsigned)&STATUS*8)+2;
volatile bit nPD @ ((unsigned)&STATUS*8)+3;
volatile bit nTO @ ((unsigned)&STATUS*8)+4;
volatile bit IRP @ ((unsigned)&STATUS*8)+7;
volatile bit RP0 @ ((unsigned)&STATUS*8)+5;
volatile bit RP1 @ ((unsigned)&STATUS*8)+6;

volatile union {
struct {
unsigned C : 1;
unsigned DC : 1;
unsigned Z : 1;
unsigned nPD : 1;
unsigned nTO : 1;
unsigned RP : 2;
unsigned IRP : 1;
};
struct {
unsigned : 5;
unsigned RP0 : 1;
unsigned RP1 : 1;
};
} STATUSbits @ 0x003;



volatile unsigned char FSR @ 0x004;



volatile unsigned char PORTA @ 0x005;

volatile bit RA0 @ ((unsigned)&PORTA*8)+0;
volatile bit RA1 @ ((unsigned)&PORTA*8)+1;
volatile bit RA2 @ ((unsigned)&PORTA*8)+2;
volatile bit RA3 @ ((unsigned)&PORTA*8)+3;
volatile bit RA4 @ ((unsigned)&PORTA*8)+4;
volatile bit RA5 @ ((unsigned)&PORTA*8)+5;

volatile union {
struct {
unsigned RA0 : 1;
unsigned RA1 : 1;
unsigned RA2 : 1;
unsigned RA3 : 1;
unsigned RA4 : 1;
unsigned RA5 : 1;
};
} PORTAbits @ 0x005;



volatile unsigned char PORTB @ 0x006;

volatile bit RB0 @ ((unsigned)&PORTB*8)+0;
volatile bit RB1 @ ((unsigned)&PORTB*8)+1;
volatile bit RB2 @ ((unsigned)&PORTB*8)+2;
volatile bit RB3 @ ((unsigned)&PORTB*8)+3;
volatile bit RB4 @ ((unsigned)&PORTB*8)+4;
volatile bit RB5 @ ((unsigned)&PORTB*8)+5;
volatile bit RB6 @ ((unsigned)&PORTB*8)+6;
volatile bit RB7 @ ((unsigned)&PORTB*8)+7;

volatile union {
struct {
unsigned RB0 : 1;
unsigned RB1 : 1;
unsigned RB2 : 1;
unsigned RB3 : 1;
unsigned RB4 : 1;
unsigned RB5 : 1;
unsigned RB6 : 1;
unsigned RB7 : 1;
};
} PORTBbits @ 0x006;



volatile unsigned char PORTC @ 0x007;

volatile bit RC0 @ ((unsigned)&PORTC*8)+0;
volatile bit RC1 @ ((unsigned)&PORTC*8)+1;
volatile bit RC2 @ ((unsigned)&PORTC*8)+2;
volatile bit RC3 @ ((unsigned)&PORTC*8)+3;
volatile bit RC4 @ ((unsigned)&PORTC*8)+4;
volatile bit RC5 @ ((unsigned)&PORTC*8)+5;
volatile bit RC6 @ ((unsigned)&PORTC*8)+6;
volatile bit RC7 @ ((unsigned)&PORTC*8)+7;

volatile union {
struct {
unsigned RC0 : 1;
unsigned RC1 : 1;
unsigned RC2 : 1;
unsigned RC3 : 1;
unsigned RC4 : 1;
unsigned RC5 : 1;
unsigned RC6 : 1;
unsigned RC7 : 1;
};
} PORTCbits @ 0x007;



volatile unsigned char PORTD @ 0x008;

volatile bit RD0 @ ((unsigned)&PORTD*8)+0;
volatile bit RD1 @ ((unsigned)&PORTD*8)+1;
volatile bit RD2 @ ((unsigned)&PORTD*8)+2;
volatile bit RD3 @ ((unsigned)&PORTD*8)+3;
volatile bit RD4 @ ((unsigned)&PORTD*8)+4;
volatile bit RD5 @ ((unsigned)&PORTD*8)+5;
volatile bit RD6 @ ((unsigned)&PORTD*8)+6;
volatile bit RD7 @ ((unsigned)&PORTD*8)+7;

volatile union {
struct {
unsigned RD0 : 1;
unsigned RD1 : 1;
unsigned RD2 : 1;
unsigned RD3 : 1;
unsigned RD4 : 1;
unsigned RD5 : 1;
unsigned RD6 : 1;
unsigned RD7 : 1;
};
} PORTDbits @ 0x008;



volatile unsigned char PORTE @ 0x009;

volatile bit RE0 @ ((unsigned)&PORTE*8)+0;
volatile bit RE1 @ ((unsigned)&PORTE*8)+1;
volatile bit RE2 @ ((unsigned)&PORTE*8)+2;

volatile union {
struct {
unsigned RE0 : 1;
unsigned RE1 : 1;
unsigned RE2 : 1;
};
} PORTEbits @ 0x009;



volatile unsigned char PCLATH @ 0x00A;


volatile union {
struct {
unsigned PCLATH : 5;
};
} PCLATHbits @ 0x00A;



volatile unsigned char INTCON @ 0x00B;

volatile bit RBIF @ ((unsigned)&INTCON*8)+0;
volatile bit INTF @ ((unsigned)&INTCON*8)+1;
volatile bit TMR0IF @ ((unsigned)&INTCON*8)+2;
volatile bit RBIE @ ((unsigned)&INTCON*8)+3;
volatile bit INTE @ ((unsigned)&INTCON*8)+4;
volatile bit TMR0IE @ ((unsigned)&INTCON*8)+5;
volatile bit PEIE @ ((unsigned)&INTCON*8)+6;
volatile bit GIE @ ((unsigned)&INTCON*8)+7;
volatile bit T0IF @ ((unsigned)&INTCON*8)+2;
volatile bit T0IE @ ((unsigned)&INTCON*8)+5;

volatile union {
struct {
unsigned RBIF : 1;
unsigned INTF : 1;
unsigned TMR0IF : 1;
unsigned RBIE : 1;
unsigned INTE : 1;
unsigned TMR0IE : 1;
unsigned PEIE : 1;
unsigned GIE : 1;
};
struct {
unsigned : 2;
unsigned T0IF : 1;
unsigned : 2;
unsigned T0IE : 1;
};
} INTCONbits @ 0x00B;



volatile unsigned char PIR1 @ 0x00C;

volatile bit TMR1IF @ ((unsigned)&PIR1*8)+0;
volatile bit TMR2IF @ ((unsigned)&PIR1*8)+1;
volatile bit CCP1IF @ ((unsigned)&PIR1*8)+2;
volatile bit SSPIF @ ((unsigned)&PIR1*8)+3;
volatile bit TXIF @ ((unsigned)&PIR1*8)+4;
volatile bit RCIF @ ((unsigned)&PIR1*8)+5;
volatile bit ADIF @ ((unsigned)&PIR1*8)+6;
volatile bit PSPIF @ ((unsigned)&PIR1*8)+7;

volatile union {
struct {
unsigned TMR1IF : 1;
unsigned TMR2IF : 1;
unsigned CCP1IF : 1;
unsigned SSPIF : 1;
unsigned TXIF : 1;
unsigned RCIF : 1;
unsigned ADIF : 1;
unsigned PSPIF : 1;
};
struct {
unsigned : 1;
unsigned : 1;
unsigned : 1;
unsigned : 1;
unsigned : 2;
unsigned : 1;
unsigned : 1;
};
} PIR1bits @ 0x00C;



volatile unsigned char PIR2 @ 0x00D;

volatile bit CCP2IF @ ((unsigned)&PIR2*8)+0;
volatile bit BCLIF @ ((unsigned)&PIR2*8)+3;
volatile bit EEIF @ ((unsigned)&PIR2*8)+4;
volatile bit CMIF @ ((unsigned)&PIR2*8)+6;

volatile union {
struct {
unsigned CCP2IF : 1;
unsigned : 2;
unsigned BCLIF : 1;
unsigned EEIF : 1;
unsigned : 1;
unsigned CMIF : 1;
};
} PIR2bits @ 0x00D;




volatile unsigned char TMR1L @ 0x00E;



volatile unsigned char TMR1H @ 0x00F;



volatile unsigned int TMR1 @ 0x00E;


volatile unsigned char T1CON @ 0x010;

volatile bit TMR1ON @ ((unsigned)&T1CON*8)+0;
volatile bit TMR1CS @ ((unsigned)&T1CON*8)+1;
volatile bit nT1SYNC @ ((unsigned)&T1CON*8)+2;
volatile bit T1OSCEN @ ((unsigned)&T1CON*8)+3;
volatile bit T1SYNC @ ((unsigned)&T1CON*8)+2;
volatile bit T1CKPS0 @ ((unsigned)&T1CON*8)+4;
volatile bit T1CKPS1 @ ((unsigned)&T1CON*8)+5;
volatile bit T1INSYNC @ ((unsigned)&T1CON*8)+2;

volatile union {
struct {
unsigned TMR1ON : 1;
unsigned TMR1CS : 1;
unsigned nT1SYNC : 1;
unsigned T1OSCEN : 1;
unsigned T1CKPS : 2;
};
struct {
unsigned : 2;
unsigned T1SYNC : 1;
unsigned : 1;
unsigned T1CKPS0 : 1;
unsigned T1CKPS1 : 1;
};
struct {
unsigned : 2;
unsigned T1INSYNC : 1;
};
} T1CONbits @ 0x010;



volatile unsigned char TMR2 @ 0x011;



volatile unsigned char T2CON @ 0x012;

volatile bit TMR2ON @ ((unsigned)&T2CON*8)+2;
volatile bit T2CKPS0 @ ((unsigned)&T2CON*8)+0;
volatile bit T2CKPS1 @ ((unsigned)&T2CON*8)+1;
volatile bit TOUTPS0 @ ((unsigned)&T2CON*8)+3;
volatile bit TOUTPS1 @ ((unsigned)&T2CON*8)+4;
volatile bit TOUTPS2 @ ((unsigned)&T2CON*8)+5;
volatile bit TOUTPS3 @ ((unsigned)&T2CON*8)+6;

volatile union {
struct {
unsigned T2CKPS : 2;
unsigned TMR2ON : 1;
unsigned TOUTPS : 4;
};
struct {
unsigned T2CKPS0 : 1;
unsigned T2CKPS1 : 1;
unsigned : 1;
unsigned TOUTPS0 : 1;
unsigned TOUTPS1 : 1;
unsigned TOUTPS2 : 1;
unsigned TOUTPS3 : 1;
};
} T2CONbits @ 0x012;



volatile unsigned char SSPBUF @ 0x013;



volatile unsigned char SSPCON @ 0x014;

volatile bit CKP @ ((unsigned)&SSPCON*8)+4;
volatile bit SSPEN @ ((unsigned)&SSPCON*8)+5;
volatile bit SSPOV @ ((unsigned)&SSPCON*8)+6;
volatile bit WCOL @ ((unsigned)&SSPCON*8)+7;
volatile bit SSPM0 @ ((unsigned)&SSPCON*8)+0;
volatile bit SSPM1 @ ((unsigned)&SSPCON*8)+1;
volatile bit SSPM2 @ ((unsigned)&SSPCON*8)+2;
volatile bit SSPM3 @ ((unsigned)&SSPCON*8)+3;

volatile union {
struct {
unsigned SSPM : 4;
unsigned CKP : 1;
unsigned SSPEN : 1;
unsigned SSPOV : 1;
unsigned WCOL : 1;
};
struct {
unsigned SSPM0 : 1;
unsigned SSPM1 : 1;
unsigned SSPM2 : 1;
unsigned SSPM3 : 1;
};
} SSPCONbits @ 0x014;




volatile unsigned char CCPR1L @ 0x015;



volatile unsigned char CCPR1H @ 0x016;



volatile unsigned int CCPR1 @ 0x015;


volatile unsigned char CCP1CON @ 0x017;

volatile bit CCP1Y @ ((unsigned)&CCP1CON*8)+4;
volatile bit CCP1X @ ((unsigned)&CCP1CON*8)+5;
volatile bit CCP1M0 @ ((unsigned)&CCP1CON*8)+0;
volatile bit CCP1M1 @ ((unsigned)&CCP1CON*8)+1;
volatile bit CCP1M2 @ ((unsigned)&CCP1CON*8)+2;
volatile bit CCP1M3 @ ((unsigned)&CCP1CON*8)+3;

volatile union {
struct {
unsigned CCP1M : 4;
unsigned CCP1Y : 1;
unsigned CCP1X : 1;
};
struct {
unsigned CCP1M0 : 1;
unsigned CCP1M1 : 1;
unsigned CCP1M2 : 1;
unsigned CCP1M3 : 1;
};
} CCP1CONbits @ 0x017;



volatile unsigned char RCSTA @ 0x018;

volatile bit RX9D @ ((unsigned)&RCSTA*8)+0;
volatile bit OERR @ ((unsigned)&RCSTA*8)+1;
volatile bit FERR @ ((unsigned)&RCSTA*8)+2;
volatile bit ADDEN @ ((unsigned)&RCSTA*8)+3;
volatile bit CREN @ ((unsigned)&RCSTA*8)+4;
volatile bit SREN @ ((unsigned)&RCSTA*8)+5;
volatile bit RX9 @ ((unsigned)&RCSTA*8)+6;
volatile bit SPEN @ ((unsigned)&RCSTA*8)+7;
volatile bit RCD8 @ ((unsigned)&RCSTA*8)+0;
volatile bit RC9 @ ((unsigned)&RCSTA*8)+6;
volatile bit nRC8 @ ((unsigned)&RCSTA*8)+6;
volatile bit RC8_9 @ ((unsigned)&RCSTA*8)+6;

volatile union {
struct {
unsigned RX9D : 1;
unsigned OERR : 1;
unsigned FERR : 1;
unsigned ADDEN : 1;
unsigned CREN : 1;
unsigned SREN : 1;
unsigned RX9 : 1;
unsigned SPEN : 1;
};
struct {
unsigned RCD8 : 1;
unsigned : 5;
unsigned RC9 : 1;
};
struct {
unsigned : 6;
unsigned nRC8 : 1;
};
struct {
unsigned : 6;
unsigned RC8_9 : 1;
};
} RCSTAbits @ 0x018;



volatile unsigned char TXREG @ 0x019;



volatile unsigned char RCREG @ 0x01A;




volatile unsigned char CCPR2L @ 0x01B;



volatile unsigned char CCPR2H @ 0x01C;



volatile unsigned int CCPR2 @ 0x01B;


volatile unsigned char CCP2CON @ 0x01D;

volatile bit CCP2Y @ ((unsigned)&CCP2CON*8)+4;
volatile bit CCP2X @ ((unsigned)&CCP2CON*8)+5;
volatile bit CCP2M0 @ ((unsigned)&CCP2CON*8)+0;
volatile bit CCP2M1 @ ((unsigned)&CCP2CON*8)+1;
volatile bit CCP2M2 @ ((unsigned)&CCP2CON*8)+2;
volatile bit CCP2M3 @ ((unsigned)&CCP2CON*8)+3;

volatile union {
struct {
unsigned CCP2M : 4;
unsigned CCP2Y : 1;
unsigned CCP2X : 1;
};
struct {
unsigned CCP2M0 : 1;
unsigned CCP2M1 : 1;
unsigned CCP2M2 : 1;
unsigned CCP2M3 : 1;
};
} CCP2CONbits @ 0x01D;



volatile unsigned char ADRESH @ 0x01E;



volatile unsigned char ADCON0 @ 0x01F;

volatile bit ADON @ ((unsigned)&ADCON0*8)+0;
volatile bit GO_nDONE @ ((unsigned)&ADCON0*8)+2;
volatile bit GO @ ((unsigned)&ADCON0*8)+2;
volatile bit CHS0 @ ((unsigned)&ADCON0*8)+3;
volatile bit CHS1 @ ((unsigned)&ADCON0*8)+4;
volatile bit CHS2 @ ((unsigned)&ADCON0*8)+5;
volatile bit ADCS0 @ ((unsigned)&ADCON0*8)+6;
volatile bit ADCS1 @ ((unsigned)&ADCON0*8)+7;
volatile bit nDONE @ ((unsigned)&ADCON0*8)+2;
volatile bit GO_DONE @ ((unsigned)&ADCON0*8)+2;

volatile union {
struct {
unsigned ADON : 1;
unsigned : 1;
unsigned GO_nDONE : 1;
unsigned CHS : 3;
unsigned ADCS : 2;
};
struct {
unsigned : 1;
unsigned : 1;
unsigned : 1;
unsigned : 3;
unsigned : 2;
};
struct {
unsigned : 2;
unsigned GO : 1;
unsigned CHS0 : 1;
unsigned CHS1 : 1;
unsigned CHS2 : 1;
unsigned ADCS0 : 1;
unsigned ADCS1 : 1;
};
struct {
unsigned : 2;
unsigned nDONE : 1;
};
struct {
unsigned : 2;
unsigned GO_DONE : 1;
};
} ADCON0bits @ 0x01F;

# 639
volatile unsigned char OPTION_REG @ 0x081;

volatile bit PSA @ ((unsigned)&OPTION_REG*8)+3;
volatile bit T0SE @ ((unsigned)&OPTION_REG*8)+4;
volatile bit T0CS @ ((unsigned)&OPTION_REG*8)+5;
volatile bit INTEDG @ ((unsigned)&OPTION_REG*8)+6;
volatile bit nRBPU @ ((unsigned)&OPTION_REG*8)+7;
volatile bit PS0 @ ((unsigned)&OPTION_REG*8)+0;
volatile bit PS1 @ ((unsigned)&OPTION_REG*8)+1;
volatile bit PS2 @ ((unsigned)&OPTION_REG*8)+2;

volatile union {
struct {
unsigned PS : 3;
unsigned PSA : 1;
unsigned T0SE : 1;
unsigned T0CS : 1;
unsigned INTEDG : 1;
unsigned nRBPU : 1;
};
struct {
unsigned PS0 : 1;
unsigned PS1 : 1;
unsigned PS2 : 1;
};
} OPTION_REGbits @ 0x081;



volatile unsigned char TRISA @ 0x085;

volatile bit TRISA0 @ ((unsigned)&TRISA*8)+0;
volatile bit TRISA1 @ ((unsigned)&TRISA*8)+1;
volatile bit TRISA2 @ ((unsigned)&TRISA*8)+2;
volatile bit TRISA3 @ ((unsigned)&TRISA*8)+3;
volatile bit TRISA4 @ ((unsigned)&TRISA*8)+4;
volatile bit TRISA5 @ ((unsigned)&TRISA*8)+5;

volatile union {
struct {
unsigned TRISA0 : 1;
unsigned TRISA1 : 1;
unsigned TRISA2 : 1;
unsigned TRISA3 : 1;
unsigned TRISA4 : 1;
unsigned TRISA5 : 1;
};
} TRISAbits @ 0x085;



volatile unsigned char TRISB @ 0x086;

volatile bit TRISB0 @ ((unsigned)&TRISB*8)+0;
volatile bit TRISB1 @ ((unsigned)&TRISB*8)+1;
volatile bit TRISB2 @ ((unsigned)&TRISB*8)+2;
volatile bit TRISB3 @ ((unsigned)&TRISB*8)+3;
volatile bit TRISB4 @ ((unsigned)&TRISB*8)+4;
volatile bit TRISB5 @ ((unsigned)&TRISB*8)+5;
volatile bit TRISB6 @ ((unsigned)&TRISB*8)+6;
volatile bit TRISB7 @ ((unsigned)&TRISB*8)+7;

volatile union {
struct {
unsigned TRISB0 : 1;
unsigned TRISB1 : 1;
unsigned TRISB2 : 1;
unsigned TRISB3 : 1;
unsigned TRISB4 : 1;
unsigned TRISB5 : 1;
unsigned TRISB6 : 1;
unsigned TRISB7 : 1;
};
} TRISBbits @ 0x086;



volatile unsigned char TRISC @ 0x087;

volatile bit TRISC0 @ ((unsigned)&TRISC*8)+0;
volatile bit TRISC1 @ ((unsigned)&TRISC*8)+1;
volatile bit TRISC2 @ ((unsigned)&TRISC*8)+2;
volatile bit TRISC3 @ ((unsigned)&TRISC*8)+3;
volatile bit TRISC4 @ ((unsigned)&TRISC*8)+4;
volatile bit TRISC5 @ ((unsigned)&TRISC*8)+5;
volatile bit TRISC6 @ ((unsigned)&TRISC*8)+6;
volatile bit TRISC7 @ ((unsigned)&TRISC*8)+7;

volatile union {
struct {
unsigned TRISC0 : 1;
unsigned TRISC1 : 1;
unsigned TRISC2 : 1;
unsigned TRISC3 : 1;
unsigned TRISC4 : 1;
unsigned TRISC5 : 1;
unsigned TRISC6 : 1;
unsigned TRISC7 : 1;
};
} TRISCbits @ 0x087;



volatile unsigned char TRISD @ 0x088;

volatile bit TRISD0 @ ((unsigned)&TRISD*8)+0;
volatile bit TRISD1 @ ((unsigned)&TRISD*8)+1;
volatile bit TRISD2 @ ((unsigned)&TRISD*8)+2;
volatile bit TRISD3 @ ((unsigned)&TRISD*8)+3;
volatile bit TRISD4 @ ((unsigned)&TRISD*8)+4;
volatile bit TRISD5 @ ((unsigned)&TRISD*8)+5;
volatile bit TRISD6 @ ((unsigned)&TRISD*8)+6;
volatile bit TRISD7 @ ((unsigned)&TRISD*8)+7;

volatile union {
struct {
unsigned TRISD0 : 1;
unsigned TRISD1 : 1;
unsigned TRISD2 : 1;
unsigned TRISD3 : 1;
unsigned TRISD4 : 1;
unsigned TRISD5 : 1;
unsigned TRISD6 : 1;
unsigned TRISD7 : 1;
};
} TRISDbits @ 0x088;



volatile unsigned char TRISE @ 0x089;

volatile bit TRISE0 @ ((unsigned)&TRISE*8)+0;
volatile bit TRISE1 @ ((unsigned)&TRISE*8)+1;
volatile bit TRISE2 @ ((unsigned)&TRISE*8)+2;
volatile bit PSPMODE @ ((unsigned)&TRISE*8)+4;
volatile bit IBOV @ ((unsigned)&TRISE*8)+5;
volatile bit OBF @ ((unsigned)&TRISE*8)+6;
volatile bit IBF @ ((unsigned)&TRISE*8)+7;

volatile union {
struct {
unsigned TRISE0 : 1;
unsigned TRISE1 : 1;
unsigned TRISE2 : 1;
unsigned : 1;
unsigned PSPMODE : 1;
unsigned IBOV : 1;
unsigned OBF : 1;
unsigned IBF : 1;
};
} TRISEbits @ 0x089;



volatile unsigned char PIE1 @ 0x08C;

volatile bit TMR1IE @ ((unsigned)&PIE1*8)+0;
volatile bit TMR2IE @ ((unsigned)&PIE1*8)+1;
volatile bit CCP1IE @ ((unsigned)&PIE1*8)+2;
volatile bit SSPIE @ ((unsigned)&PIE1*8)+3;
volatile bit TXIE @ ((unsigned)&PIE1*8)+4;
volatile bit RCIE @ ((unsigned)&PIE1*8)+5;
volatile bit ADIE @ ((unsigned)&PIE1*8)+6;
volatile bit PSPIE @ ((unsigned)&PIE1*8)+7;

volatile union {
struct {
unsigned TMR1IE : 1;
unsigned TMR2IE : 1;
unsigned CCP1IE : 1;
unsigned SSPIE : 1;
unsigned TXIE : 1;
unsigned RCIE : 1;
unsigned ADIE : 1;
unsigned PSPIE : 1;
};
} PIE1bits @ 0x08C;



volatile unsigned char PIE2 @ 0x08D;

volatile bit CCP2IE @ ((unsigned)&PIE2*8)+0;
volatile bit BCLIE @ ((unsigned)&PIE2*8)+3;
volatile bit EEIE @ ((unsigned)&PIE2*8)+4;
volatile bit CMIE @ ((unsigned)&PIE2*8)+6;

volatile union {
struct {
unsigned CCP2IE : 1;
unsigned : 2;
unsigned BCLIE : 1;
unsigned EEIE : 1;
unsigned : 1;
unsigned CMIE : 1;
};
} PIE2bits @ 0x08D;



volatile unsigned char PCON @ 0x08E;

volatile bit nBOR @ ((unsigned)&PCON*8)+0;
volatile bit nPOR @ ((unsigned)&PCON*8)+1;
volatile bit nBO @ ((unsigned)&PCON*8)+0;

volatile union {
struct {
unsigned nBOR : 1;
unsigned nPOR : 1;
};
struct {
unsigned nBO : 1;
};
} PCONbits @ 0x08E;



volatile unsigned char SSPCON2 @ 0x091;

volatile bit SEN @ ((unsigned)&SSPCON2*8)+0;
volatile bit RSEN @ ((unsigned)&SSPCON2*8)+1;
volatile bit PEN @ ((unsigned)&SSPCON2*8)+2;
volatile bit RCEN @ ((unsigned)&SSPCON2*8)+3;
volatile bit ACKEN @ ((unsigned)&SSPCON2*8)+4;
volatile bit ACKDT @ ((unsigned)&SSPCON2*8)+5;
volatile bit ACKSTAT @ ((unsigned)&SSPCON2*8)+6;
volatile bit GCEN @ ((unsigned)&SSPCON2*8)+7;

volatile union {
struct {
unsigned SEN : 1;
unsigned RSEN : 1;
unsigned PEN : 1;
unsigned RCEN : 1;
unsigned ACKEN : 1;
unsigned ACKDT : 1;
unsigned ACKSTAT : 1;
unsigned GCEN : 1;
};
} SSPCON2bits @ 0x091;



volatile unsigned char PR2 @ 0x092;



volatile unsigned char SSPADD @ 0x093;



volatile unsigned char SSPSTAT @ 0x094;

volatile bit BF @ ((unsigned)&SSPSTAT*8)+0;
volatile bit UA @ ((unsigned)&SSPSTAT*8)+1;
volatile bit R_nW @ ((unsigned)&SSPSTAT*8)+2;
volatile bit S @ ((unsigned)&SSPSTAT*8)+3;
volatile bit P @ ((unsigned)&SSPSTAT*8)+4;
volatile bit D_nA @ ((unsigned)&SSPSTAT*8)+5;
volatile bit CKE @ ((unsigned)&SSPSTAT*8)+6;
volatile bit SMP @ ((unsigned)&SSPSTAT*8)+7;
volatile bit R @ ((unsigned)&SSPSTAT*8)+2;
volatile bit D @ ((unsigned)&SSPSTAT*8)+5;
volatile bit I2C_READ @ ((unsigned)&SSPSTAT*8)+2;
volatile bit I2C_START @ ((unsigned)&SSPSTAT*8)+3;
volatile bit I2C_STOP @ ((unsigned)&SSPSTAT*8)+4;
volatile bit I2C_DATA @ ((unsigned)&SSPSTAT*8)+5;
volatile bit nW @ ((unsigned)&SSPSTAT*8)+2;
volatile bit nA @ ((unsigned)&SSPSTAT*8)+5;
volatile bit nWRITE @ ((unsigned)&SSPSTAT*8)+2;
volatile bit nADDRESS @ ((unsigned)&SSPSTAT*8)+5;
volatile bit R_W @ ((unsigned)&SSPSTAT*8)+2;
volatile bit D_A @ ((unsigned)&SSPSTAT*8)+5;
volatile bit READ_WRITE @ ((unsigned)&SSPSTAT*8)+2;
volatile bit DATA_ADDRESS @ ((unsigned)&SSPSTAT*8)+5;

volatile union {
struct {
unsigned BF : 1;
unsigned UA : 1;
unsigned R_nW : 1;
unsigned S : 1;
unsigned P : 1;
unsigned D_nA : 1;
unsigned CKE : 1;
unsigned SMP : 1;
};
struct {
unsigned : 1;
unsigned : 1;
unsigned : 1;
unsigned : 1;
unsigned : 1;
unsigned : 1;
unsigned : 1;
unsigned : 1;
};
struct {
unsigned : 2;
unsigned R : 1;
unsigned : 2;
unsigned D : 1;
};
struct {
unsigned : 2;
unsigned I2C_READ : 1;
unsigned I2C_START : 1;
unsigned I2C_STOP : 1;
unsigned I2C_DATA : 1;
};
struct {
unsigned : 2;
unsigned nW : 1;
unsigned : 2;
unsigned nA : 1;
};
struct {
unsigned : 2;
unsigned nWRITE : 1;
unsigned : 2;
unsigned nADDRESS : 1;
};
struct {
unsigned : 2;
unsigned R_W : 1;
unsigned : 2;
unsigned D_A : 1;
};
struct {
unsigned : 2;
unsigned READ_WRITE : 1;
unsigned : 2;
unsigned DATA_ADDRESS : 1;
};
} SSPSTATbits @ 0x094;



volatile unsigned char TXSTA @ 0x098;

volatile bit TX9D @ ((unsigned)&TXSTA*8)+0;
volatile bit TRMT @ ((unsigned)&TXSTA*8)+1;
volatile bit BRGH @ ((unsigned)&TXSTA*8)+2;
volatile bit SYNC @ ((unsigned)&TXSTA*8)+4;
volatile bit TXEN @ ((unsigned)&TXSTA*8)+5;
volatile bit TX9 @ ((unsigned)&TXSTA*8)+6;
volatile bit CSRC @ ((unsigned)&TXSTA*8)+7;
volatile bit TXD8 @ ((unsigned)&TXSTA*8)+0;
volatile bit nTX8 @ ((unsigned)&TXSTA*8)+6;
volatile bit TX8_9 @ ((unsigned)&TXSTA*8)+6;

volatile union {
struct {
unsigned TX9D : 1;
unsigned TRMT : 1;
unsigned BRGH : 1;
unsigned : 1;
unsigned SYNC : 1;
unsigned TXEN : 1;
unsigned TX9 : 1;
unsigned CSRC : 1;
};
struct {
unsigned TXD8 : 1;
unsigned : 5;
unsigned nTX8 : 1;
};
struct {
unsigned : 6;
unsigned TX8_9 : 1;
};
} TXSTAbits @ 0x098;



volatile unsigned char SPBRG @ 0x099;



volatile unsigned char CMCON @ 0x09C;

volatile bit CIS @ ((unsigned)&CMCON*8)+3;
volatile bit C1INV @ ((unsigned)&CMCON*8)+4;
volatile bit C2INV @ ((unsigned)&CMCON*8)+5;
volatile bit C1OUT @ ((unsigned)&CMCON*8)+6;
volatile bit C2OUT @ ((unsigned)&CMCON*8)+7;
volatile bit CM0 @ ((unsigned)&CMCON*8)+0;
volatile bit CM1 @ ((unsigned)&CMCON*8)+1;
volatile bit CM2 @ ((unsigned)&CMCON*8)+2;

volatile union {
struct {
unsigned CM : 3;
unsigned CIS : 1;
unsigned C1INV : 1;
unsigned C2INV : 1;
unsigned C1OUT : 1;
unsigned C2OUT : 1;
};
struct {
unsigned CM0 : 1;
unsigned CM1 : 1;
unsigned CM2 : 1;
};
} CMCONbits @ 0x09C;



volatile unsigned char CVRCON @ 0x09D;

volatile bit CVRR @ ((unsigned)&CVRCON*8)+5;
volatile bit CVROE @ ((unsigned)&CVRCON*8)+6;
volatile bit CVREN @ ((unsigned)&CVRCON*8)+7;
volatile bit CVR0 @ ((unsigned)&CVRCON*8)+0;
volatile bit CVR1 @ ((unsigned)&CVRCON*8)+1;
volatile bit CVR2 @ ((unsigned)&CVRCON*8)+2;
volatile bit CVR3 @ ((unsigned)&CVRCON*8)+3;

volatile union {
struct {
unsigned CVR : 4;
unsigned : 1;
unsigned CVRR : 1;
unsigned CVROE : 1;
unsigned CVREN : 1;
};
struct {
unsigned CVR0 : 1;
unsigned CVR1 : 1;
unsigned CVR2 : 1;
unsigned CVR3 : 1;
};
} CVRCONbits @ 0x09D;



volatile unsigned char ADRESL @ 0x09E;



volatile unsigned char ADCON1 @ 0x09F;

volatile bit ADCS2 @ ((unsigned)&ADCON1*8)+6;
volatile bit ADFM @ ((unsigned)&ADCON1*8)+7;
volatile bit PCFG0 @ ((unsigned)&ADCON1*8)+0;
volatile bit PCFG1 @ ((unsigned)&ADCON1*8)+1;
volatile bit PCFG2 @ ((unsigned)&ADCON1*8)+2;
volatile bit PCFG3 @ ((unsigned)&ADCON1*8)+3;

volatile union {
struct {
unsigned PCFG : 4;
unsigned : 2;
unsigned ADCS2 : 1;
unsigned ADFM : 1;
};
struct {
unsigned PCFG0 : 1;
unsigned PCFG1 : 1;
unsigned PCFG2 : 1;
unsigned PCFG3 : 1;
};
} ADCON1bits @ 0x09F;

# 1111
volatile unsigned char EEDATA @ 0x10C;



volatile unsigned char EEADR @ 0x10D;



volatile unsigned char EEDATH @ 0x10E;


volatile union {
struct {
unsigned : 6;
};
} EEDATHbits @ 0x10E;



volatile unsigned char EEADRH @ 0x10F;


volatile union {
struct {
unsigned : 5;
};
} EEADRHbits @ 0x10F;

# 1146
volatile unsigned char EECON1 @ 0x18C;

volatile bit RD @ ((unsigned)&EECON1*8)+0;
volatile bit WR @ ((unsigned)&EECON1*8)+1;
volatile bit WREN @ ((unsigned)&EECON1*8)+2;
volatile bit WRERR @ ((unsigned)&EECON1*8)+3;
volatile bit EEPGD @ ((unsigned)&EECON1*8)+7;

volatile union {
struct {
unsigned RD : 1;
unsigned WR : 1;
unsigned WREN : 1;
unsigned WRERR : 1;
unsigned : 3;
unsigned EEPGD : 1;
};
} EECON1bits @ 0x18C;



volatile unsigned char EECON2 @ 0x18D;


# 27 "C:\Program Files\HI-TECH Software\PICC\9.82\include\pic.h"
#pragma inline(_nop)
extern void _nop(void);

# 80
extern unsigned int flash_read(unsigned short addr);

# 41 "C:\Program Files\HI-TECH Software\PICC\9.82\include\eeprom_routines.h"
extern unsigned char eeprom_write(unsigned char addr, unsigned char value);
extern unsigned char eeprom_read(unsigned char addr);
extern void eecpymem(volatile unsigned char *to, eeprom unsigned char *from, unsigned char size);
extern void memcpyee(eeprom unsigned char *to, const unsigned char *from, unsigned char size);


# 153 "C:\Program Files\HI-TECH Software\PICC\9.82\include\pic.h"
#pragma inline(_delay)
extern void _delay(unsigned long);

# 67 "F:\BEVERAGES_ENHANCEMENT\SOFTWARE_DESIGN\MASTER_PIC_16F877A\2015_09_13\includes.h"
void Port_Init();

# 6 "F:\BEVERAGES_ENHANCEMENT\SOFTWARE_DESIGN\MASTER_PIC_16F877A\2015_09_13\Beverage_services.h"
enum valve_flags{
_Milk_Valve_Forward = 1,
_Milk_Valve_Reverse,
_Mixing_Hot_Water_Valve,
_Hot_Water_Valve,
_Coffee_Hot_Water_Valve,
_Coffee_Valve,
_Tea_Hot_Water_Valve,
_Tea_Valve,
_Viber_Motor,
_Heater1,
_Heater2
};
enum valve_flags _ON,_OFF;

bit Enable_Milk_Forward,
Enable_Milk_Reverse,
Enable_Mixing_Hot_Water_Valve,
Enable_Hot_Water_Valve,
Enable_Coffee_Hot_Water_Valve,
Enable_Coffee_Valve,
Enable_Tea_Hot_Water_Valve,
Enable_Tea_Valve,
Enable_Viber_Motor,
Enable_Heater1,
Enable_Heater2;

enum button_flags{
_NORMAL_COFFEE_BUTTON = 1,
_NORMAL_TEA_BUTTON,
_LIGHT_COFFEE_BUTTON,
_LIGHT_TEA_BUTTON,
_BLACK_COFFEE_BUTTON,
_BLACK_TEA_BUTTON,
_MILK_BUTTON,
_EXTRA_BUTTON,
_HOT_WATER_BUTTON,
_MENU_BUTTON
};
enum button_flags _PRESSED,_CHOICE_SELECTED,
_SHORTCUT_PRESSED;

bit _SHORTCUT;

enum mode_flags{
_Normal_Mode=1,
_Password,
_Config_Mode,
_Valves,
_Selection,
_Coffee_Dication_Time,
_Tea_Dication_Time,
_Dication_Delay,
_Hot_Water_Time,
_Milk_Reverse_Time,
_Temperature,
_Cup_Count,
_Count_Reset,
_Shortcut_Mode
};
enum mode_flags _ENABLE_MODE,_DISABLE_MODE,_PREVIOUS_MODE=0;

bit Enable_Normal_Mode,
Enable_Password,
Enable_Config_Mode,
Enable_Valves,
Enable_Selection,
Enable_Coffee_Dication_Time,
Enable_Tea_Dication_Time,
Enable_Dication_Delay,
Enable_Hot_Water_Time,
Enable_Milk_Reverse_Time,
Enable_Temperature,
Enable_Cup_Count,
Enable_Count_Reset,
Enable_Shortcut_Mode;

enum shortcut_flags{
_Countdisplay=1,
_Preparation,
_Cleaning
};
enum shortcut_flags _PROCESS=0,_PREVIOUS_PROCESS=0;

bit _Demo,_temp_flag=0,_clear=0;

struct item
{
unsigned int COFFEE_DICATION:1;
unsigned int TEA_DICATION:1;
unsigned int MIXING_HOT_WATER:1;
unsigned int MILK:1;
unsigned int VIBR_MOTOR:1;
}VALVE,MENU[9];



unsigned int i=0,j=0,password,temperature,ADC_value,time;

unsigned char Next=0,Selection_Next=0;

unsigned char buff[4];

unsigned char mem_index1,mem_index2;

# 116
void Print_Name();
void Print_Menu();
void Inidcate_Buzzer();
void Mode_Init();
void key_press();
void enable_valves();
void onthevalve();
void offthevalve();
void control_valve(unsigned int load_time, unsigned int delay_time);
void call_control_valve();
void change_modes();
void Write_ValveIn_Memory(struct item VALVE,unsigned char loc);
struct item Read_ValveFrom_Memory(unsigned char MEM);
void print_yes_no(unsigned char option);
void run_shortcut_sequence();
void count_write(unsigned char addr1,unsigned char addr2,unsigned int total_count);
int count_read(unsigned char addr1, unsigned char addr2);

# 8 "F:\BEVERAGES_ENHANCEMENT\SOFTWARE_DESIGN\MASTER_PIC_16F877A\2015_09_13\lcd.h"
unsigned char asciitable[10]={'0','1','2','3','4','5','6','7','8','9'};

void Lcd_Init();
void Lcd_Cmd(unsigned char s);
void Lcd_Data(unsigned char x);

void Lcd_String(const unsigned char* st, char clear, char second_line);
void Num_Disp(unsigned int dat,unsigned char digit,unsigned char dot);

# 22 "F:\BEVERAGES_ENHANCEMENT\SOFTWARE_DESIGN\MASTER_PIC_16F877A\2015_09_13\delay.h"
extern void DelayMs(unsigned short cnt);

# 2 "F:\BEVERAGES_ENHANCEMENT\SOFTWARE_DESIGN\MASTER_PIC_16F877A\2015_09_13\myitoa.h"
unsigned char itoai;
void myitoa(int i,char *p);
void rev(char* buf);

# 8 "F:\BEVERAGES_ENHANCEMENT\SOFTWARE_DESIGN\MASTER_PIC_16F877A\2015_09_13\uart.h"
void Uart_Init(const long int baudrate);
void SendByteSerially(unsigned char Byte);

void SendStringSerially(const unsigned char* st);

# 8 "F:\BEVERAGES_ENHANCEMENT\SOFTWARE_DESIGN\MASTER_PIC_16F877A\2015_09_13\Beverage_services.c"
void Print_Name()
{
SendByteSerially(0x01);
}

void Print_Menu()
{
switch(_PRESSED)
{
case _NORMAL_COFFEE_BUTTON: SendByteSerially(0x02);
break;
case _NORMAL_TEA_BUTTON: SendByteSerially(0x03);
break;
case _LIGHT_COFFEE_BUTTON: SendByteSerially(0x04);
break;
case _LIGHT_TEA_BUTTON: SendByteSerially(0x05);
break;
case _BLACK_COFFEE_BUTTON: SendByteSerially(0x06);
break;
case _BLACK_TEA_BUTTON: SendByteSerially(0x07);
break;
case _MILK_BUTTON: SendByteSerially(0x08);
break;
case _HOT_WATER_BUTTON: SendByteSerially(0x09);
break;
case _EXTRA_BUTTON: SendByteSerially(0x0A);
break;
}
}

void Inidcate_Buzzer()
{
RD1=1;
DelayMs(100);
RD1=0;
}

void Mode_Init()
{
Enable_Normal_Mode=0;
Enable_Config_Mode=0;
Enable_Password=0;
Enable_Valves=0;
Enable_Selection=0;
Enable_Coffee_Dication_Time=0;
Enable_Tea_Dication_Time=0;
Enable_Dication_Delay=0;
Enable_Hot_Water_Time=0;
Enable_Temperature=0;
Enable_Cup_Count=0;
Enable_Count_Reset=0;
Enable_Shortcut_Mode=0;

for(unsigned char option=0;option<9;option++)
{
MENU[option]=Read_ValveFrom_Memory(option);
}
if(eeprom_read(145)>1 || eeprom_read(146)>1)
{
SendByteSerially(0x0B);
while(1)
{
if(RC4==0)
{
eeprom_write(145,eeprom_read(145)-1);
eeprom_write(146,eeprom_read(146)-1);
SendByteSerially(0x0C);
if(eeprom_read(145)>1 && eeprom_read(145)<10)
Enable_Coffee_Hot_Water_Valve = 1;
if(eeprom_read(146)>1 && eeprom_read(146)<10)
Enable_Tea_Hot_Water_Valve = 1;
call_control_valve();
_clear=1;
}
if(RC5==0 || _clear==1)
{
_clear=0;
eeprom_write(145,0);
eeprom_write(146,0);
_DISABLE_MODE=_Shortcut_Mode;
_ENABLE_MODE=_Normal_Mode;
break;
}
}
}

}

void key_press()
{
if(!RB0 || !RB1 || !RB2 || !RB3 || !RB4 || !RB5 || !RB6 || !RB7 || !RC4 || !RC5)
{
if(RB6==0)
{
_PRESSED=_NORMAL_COFFEE_BUTTON;
}
if(RB7==0)
{
_PRESSED=_NORMAL_TEA_BUTTON;
}
if(RB4==0)
{
_PRESSED=_LIGHT_COFFEE_BUTTON;
}
if(RB5==0)
{
_PRESSED=_LIGHT_TEA_BUTTON;
}
if(RB2==0)
{
_PRESSED=_BLACK_COFFEE_BUTTON;
}
if(RB3==0)
{
_PRESSED=_BLACK_TEA_BUTTON;
}
if(RB0==0)
{
_PRESSED=_MILK_BUTTON;
}
if(RB1==0)
{
_PRESSED=_HOT_WATER_BUTTON;
}
if(RC5==0)
{
_PRESSED=_EXTRA_BUTTON;
}
if(RC4==0)
{
_PRESSED=_MENU_BUTTON;
if(_SHORTCUT==1)
_SHORTCUT=0;
else
_SHORTCUT=1;
}
}
if(_PRESSED!=_MENU_BUTTON)
{
_CHOICE_SELECTED=_PRESSED;
_SHORTCUT_PRESSED=_PRESSED;
}
}

void enable_valves()
{
if(Enable_Normal_Mode && (_PRESSED!=_MENU_BUTTON))
{
Print_Menu();
if(_PRESSED==_HOT_WATER_BUTTON)
Enable_Hot_Water_Valve=1;

if(_PRESSED)
{
if(MENU[_PRESSED-1].COFFEE_DICATION)
{
Enable_Coffee_Valve = 1;
}
if(MENU[_PRESSED-1].TEA_DICATION)
{
Enable_Tea_Valve = 1;
}
if(MENU[_PRESSED-1].MIXING_HOT_WATER)
{
Enable_Mixing_Hot_Water_Valve = 1;
}
if(MENU[_PRESSED-1].MILK)
{
Enable_Milk_Forward = 1;
Enable_Milk_Reverse = 1;
}
if(MENU[_PRESSED-1].VIBR_MOTOR)
{
Enable_Viber_Motor = 1;
}

Inidcate_Buzzer();
if(_PRESSED!=_EXTRA_BUTTON)
{
count_write(126,127,eeprom_read(126)+1);
count_write(126+(_PRESSED*2),127+(_PRESSED*2),eeprom_read(126+(_PRESSED*2))+1);
}
call_control_valve();
Print_Name();
}
}

if(Enable_Config_Mode || Enable_Normal_Mode || Enable_Shortcut_Mode)
{
switch(_PRESSED)
{
case _MENU_BUTTON: while(RC4==0 && (Enable_Normal_Mode || Enable_Config_Mode))
{
i++;
if(i==39999)
{
j++;
i=0;
key_press();
}
if(j==5)
{
Enable_Normal_Mode=0;
Enable_Config_Mode=0;
_DISABLE_MODE=_Normal_Mode;
_ENABLE_MODE=_Password;
j=0;
Enable_Config_Mode=0;
_SHORTCUT=0;
}
}
if(_SHORTCUT==1 && Enable_Shortcut_Mode==0)
{
Enable_Normal_Mode=0;
Enable_Config_Mode=0;
_ENABLE_MODE=_Shortcut_Mode;
_PROCESS=_Countdisplay;
i=0;j=0;
}
if(_SHORTCUT==0 && Enable_Shortcut_Mode==1)
{
_OFF=_Mixing_Hot_Water_Valve;
offthevalve();
_OFF=_Viber_Motor;
offthevalve();
_DISABLE_MODE=_Shortcut_Mode;
_ENABLE_MODE=_Normal_Mode;
_PROCESS=0;
_PREVIOUS_PROCESS=0;
}
break;
}
}
if(Enable_Password)
{
switch(_PRESSED)
{
case _NORMAL_COFFEE_BUTTON:
for(unsigned int i=0;i<256;i++)
{
eeprom_write(i,0x00);
}
break;
case _MILK_BUTTON: if(password>0)
{
password--;
}
break;
case _HOT_WATER_BUTTON: password++;
break;
case _MENU_BUTTON: if(password==(0+2))
{
password=0;
_DISABLE_MODE=_Password;
_ENABLE_MODE=_Valves;
}
break;
}
if(_PRESSED==_MILK_BUTTON || _PRESSED==_HOT_WATER_BUTTON)
{
Lcd_Cmd(0x8C);
Num_Disp(password,4,0);
DelayMs(150);
}
}
if(Enable_Valves)
{
switch(_PRESSED)
{
case _NORMAL_COFFEE_BUTTON: MENU[Next].COFFEE_DICATION=~MENU[Next].COFFEE_DICATION;
break;
case _NORMAL_TEA_BUTTON: MENU[Next].TEA_DICATION=~MENU[Next].TEA_DICATION;
break;
case _LIGHT_COFFEE_BUTTON: MENU[Next].MIXING_HOT_WATER=~MENU[Next].MIXING_HOT_WATER;
break;
case _LIGHT_TEA_BUTTON: MENU[Next].MILK=~MENU[Next].MILK;
break;
case _BLACK_COFFEE_BUTTON: MENU[Next].VIBR_MOTOR=~MENU[Next].VIBR_MOTOR;
break;
case _MILK_BUTTON: if(Next>0)
{
Next--;
}
break;
case _HOT_WATER_BUTTON: if(Next<7)
{
Next++;
}
break;
case _MENU_BUTTON: _DISABLE_MODE=_Valves;
_ENABLE_MODE=_Selection;
Next=0;
break;
}
if(_PRESSED==_MILK_BUTTON || _PRESSED==_HOT_WATER_BUTTON)
{
Lcd_Cmd(0x86);
myitoa(Next+1,buff);
Lcd_String(buff,0,0);
}
if(_PRESSED && (_PRESSED!=_MENU_BUTTON))
{
Write_ValveIn_Memory(MENU[Next],Next);
print_yes_no(Next);
DelayMs(50);
}
}
if(Enable_Selection)
{
switch(_PRESSED)
{
case _NORMAL_COFFEE_BUTTON: if(Selection_Next>0)
{
Selection_Next--;
Next=0;
}
break;
case _NORMAL_TEA_BUTTON: if(Selection_Next<7)
{
Selection_Next++;
Next=0;
}
break;
case _LIGHT_COFFEE_BUTTON: if(Next>0)
{
Next--;
}
break;
case _LIGHT_TEA_BUTTON: if(Next<9)
{
Next++;
}
break;
case _BLACK_COFFEE_BUTTON:
break;
case _BLACK_TEA_BUTTON: _Demo=1;
break;
case _MILK_BUTTON: if(time>0)
{
time--;
}
break;
case _HOT_WATER_BUTTON: time++;
break;
case _EXTRA_BUTTON: _DISABLE_MODE=_Selection;
_ENABLE_MODE=_Valves;
Selection_Next=0;
Next=0;
break;
case _MENU_BUTTON: _DISABLE_MODE=_Selection;
_ENABLE_MODE=_Coffee_Dication_Time;
Selection_Next=0;
break;
}
if(_PRESSED==_NORMAL_COFFEE_BUTTON || _PRESSED==_NORMAL_TEA_BUTTON || _PRESSED==_LIGHT_COFFEE_BUTTON || _PRESSED==_LIGHT_TEA_BUTTON)
{
time=eeprom_read(((12*(Selection_Next+1))-2)+Next);
}
if(_PRESSED && (_PRESSED!=_MENU_BUTTON) && (_PRESSED!=_EXTRA_BUTTON))
{
SendByteSerially(0x0D);
myitoa(Selection_Next+1,buff);
Lcd_String(buff,0,0);
if(!(Next%2))
{
Lcd_String("LOAD ",0,1);
Lcd_Data(asciitable[(Next/2)+1]);
if(_Demo==1)
{
if(Next==0)
_ON=_OFF=_Coffee_Valve;
if(Next==2)
_ON=_OFF=_Tea_Valve;
if(Next==4)
_ON=_OFF=_Mixing_Hot_Water_Valve;
if(Next==6)
_ON=_OFF=_Milk_Valve_Forward;
if(Next==8)
_ON=_OFF=_Viber_Motor;
onthevalve();
DelayMs(time*100);
offthevalve();
_Demo=0;
}
}
else
{
Lcd_String("DELAY",0,1);
Lcd_Data(asciitable[(Next/2)+1]);
}
Lcd_Cmd(0xC9);
Num_Disp(time,2,1);
Lcd_Cmd(0xCD);
Lcd_String("SEC",0,0);
eeprom_write(((12*(Selection_Next+1))-2)+Next,time);
}

}
if(Enable_Coffee_Dication_Time)
{
switch(_PRESSED)
{
case _MILK_BUTTON: if(time>0)
{
time--;
}
break;
case _HOT_WATER_BUTTON: time++;
break;
case _EXTRA_BUTTON: eeprom_write(118,time);
_DISABLE_MODE=_Coffee_Dication_Time;
_ENABLE_MODE=_Selection;
break;
case _MENU_BUTTON: eeprom_write(118,time);
_DISABLE_MODE=_Coffee_Dication_Time;
_ENABLE_MODE=_Tea_Dication_Time;
break;
}
if(_PRESSED && (_PRESSED!=_MENU_BUTTON) && (_PRESSED!=_EXTRA_BUTTON))
{
Lcd_Cmd(0xC8);
Num_Disp(time,3,0);
}
DelayMs(20);
}
if(Enable_Tea_Dication_Time)
{
switch(_PRESSED)
{
case _MILK_BUTTON: if(time>0)
{
time--;
}
break;
case _HOT_WATER_BUTTON: time++;
break;
case _EXTRA_BUTTON: eeprom_write(119,time);
_DISABLE_MODE=_Tea_Dication_Time;
_ENABLE_MODE=_Coffee_Dication_Time;
break;
case _MENU_BUTTON: eeprom_write(119,time);
_DISABLE_MODE=_Tea_Dication_Time;
_ENABLE_MODE=_Dication_Delay;
break;
}
if(_PRESSED && (_PRESSED!=_MENU_BUTTON) && (_PRESSED!=_EXTRA_BUTTON))
{
Lcd_Cmd(0xC8);
Num_Disp(time,3,0);
}
DelayMs(20);
}
if(Enable_Dication_Delay)
{
switch(_PRESSED)
{
case _MILK_BUTTON: if(time>0)
{
time--;
}
break;
case _HOT_WATER_BUTTON: time++;
break;
case _EXTRA_BUTTON: eeprom_write(121,time);
_DISABLE_MODE=_Dication_Delay;
_ENABLE_MODE=_Tea_Dication_Time;
DelayMs(100);
break;
case _MENU_BUTTON: eeprom_write(121,time);
_DISABLE_MODE=_Dication_Delay;
_ENABLE_MODE=_Hot_Water_Time;
break;
}
if(_PRESSED && (_PRESSED!=_MENU_BUTTON) && (_PRESSED!=_EXTRA_BUTTON))
{
Lcd_Cmd(0xC8);
Num_Disp(time,3,0);
}
DelayMs(10);
}
if(Enable_Hot_Water_Time)
{
switch(_PRESSED)
{
case _MILK_BUTTON: if(time>0)
{
time--;
}
break;
case _HOT_WATER_BUTTON: time++;
break;
case _EXTRA_BUTTON: eeprom_write(147,time);
_DISABLE_MODE=_Hot_Water_Time;
_ENABLE_MODE=_Dication_Delay;
DelayMs(100);
break;
case _MENU_BUTTON: eeprom_write(147,time);
_DISABLE_MODE=_Hot_Water_Time;
_ENABLE_MODE=_Temperature;
break;
}
if(_PRESSED && (_PRESSED!=_MENU_BUTTON) && (_PRESSED!=_EXTRA_BUTTON))
{
Lcd_Cmd(0xC8);
Num_Disp(time,3,0);
}
DelayMs(10);
}
if(Enable_Temperature)
{
switch(_PRESSED)
{
case _MILK_BUTTON: if(time>20)
{
time--;
}
break;
case _HOT_WATER_BUTTON: time++;
break;
case _EXTRA_BUTTON: eeprom_write(120,time);
_DISABLE_MODE=_Temperature;
_ENABLE_MODE=_Hot_Water_Time;
break;
case _MENU_BUTTON: eeprom_write(120,time);
_DISABLE_MODE=_Temperature;
_ENABLE_MODE=_Cup_Count;
break;
}
if(_PRESSED && (_PRESSED!=_MENU_BUTTON) && (_PRESSED!=_EXTRA_BUTTON))
{
Lcd_Cmd(0xC8);
Num_Disp(time,3,0);
}
DelayMs(10);
}
if(Enable_Cup_Count)
{
switch(_PRESSED)
{
case _EXTRA_BUTTON: _DISABLE_MODE=_Cup_Count;
_ENABLE_MODE=_Temperature;
break;
case _MENU_BUTTON: _DISABLE_MODE=_Cup_Count;
_ENABLE_MODE=_Count_Reset;
break;
}
DelayMs(10);
}
if(Enable_Count_Reset)
{
switch(_PRESSED)
{
case _EXTRA_BUTTON: eeprom_write(124,time);
_DISABLE_MODE=_Count_Reset;
_ENABLE_MODE=_Cup_Count;

break;
case _MENU_BUTTON: eeprom_write(124,time);
if(time)
{
for(unsigned char index=126;index<=143;index++)
{
eeprom_write(index,0x00);
}
}
_DISABLE_MODE=_Count_Reset;
_ENABLE_MODE=_Normal_Mode;
break;
}
if(_PRESSED && (_PRESSED!=_MENU_BUTTON) && (_PRESSED!=_EXTRA_BUTTON))
{
Lcd_Cmd(0xC6);
if(_PRESSED==_HOT_WATER_BUTTON)
{
Lcd_Data('Y');;
time=1;
}
if(_PRESSED==_MILK_BUTTON)
{
Lcd_Data('N');;
time=0;
}
}
DelayMs(10);
}
if(Enable_Shortcut_Mode)
{
switch(_PRESSED)
{
case _NORMAL_COFFEE_BUTTON: if(_PROCESS==_Preparation)
{
eeprom_write(145,5);
Enable_Coffee_Hot_Water_Valve = 1;
Lcd_String("PREPARING COFFEE",1,0);
}
if(_PROCESS==_Cleaning)
{
Lcd_String("COFFEE CLEANING",1,0);
_ON=_Coffee_Valve;
onthevalve();
while(RB6!=0)
{
_ON=_Coffee_Valve;
onthevalve();
DelayMs(750);
_OFF=_Coffee_Valve;
offthevalve();
DelayMs(250);
}
}
mem_index1=128; mem_index2=129;
break;
case _NORMAL_TEA_BUTTON: if(_PROCESS==_Preparation)
{
eeprom_write(146,5);
Enable_Tea_Hot_Water_Valve = 1;
Lcd_String(" PREPARING TEA",1,0);
}
if(_PROCESS==_Cleaning)
{
Lcd_String("TEA CLEANING",1,0);
_ON=_Tea_Valve;
onthevalve();
while(RB7!=0)
{
_ON=_Tea_Valve;
onthevalve();
DelayMs(750);
_OFF=_Tea_Valve;
offthevalve();
DelayMs(250);
}
}
mem_index1=130; mem_index2=131;
break;
case _LIGHT_COFFEE_BUTTON: mem_index1=132; mem_index2=133;
break;
case _LIGHT_TEA_BUTTON: mem_index1=134; mem_index2=135;
break;
case _BLACK_COFFEE_BUTTON: mem_index1=136; mem_index2=137;
break;
case _BLACK_TEA_BUTTON: mem_index1=138; mem_index2=139;
break;
case _MILK_BUTTON: if(_PROCESS==_Cleaning)
{
Lcd_String("MILK CLEANING",1,0);
_ON=_Viber_Motor;
onthevalve();
while(RB0!=0)
{
_ON=_Milk_Valve_Forward;
onthevalve();
DelayMs(750);
_OFF=_Milk_Valve_Forward;
offthevalve();
DelayMs(250);
}
_OFF=_Viber_Motor;
offthevalve();
}
mem_index1=140; mem_index2=141;
break;
case _HOT_WATER_BUTTON: mem_index1=142; mem_index2=143;
break;
case _EXTRA_BUTTON: if(_PROCESS==_Countdisplay && _PREVIOUS_PROCESS==_Countdisplay)
{
_PROCESS=_Preparation;
}
if(_PROCESS==_Preparation && _PREVIOUS_PROCESS==_Preparation)
{
_PROCESS=_Cleaning;
}
if(_PROCESS==_Cleaning&& _PREVIOUS_PROCESS==_Cleaning)
{
_PROCESS=_Countdisplay;
}
break;
}
if(_PREVIOUS_PROCESS!=_PROCESS)
{
if(_PROCESS==_Countdisplay)
{
Lcd_String("COUNT DISPLAY",1,0);
}
if(_PROCESS==_Preparation)
{
Lcd_String("DICATION",1,0);
Lcd_String("PREPARATION",0,1);
}
if(_PROCESS==_Cleaning)
{
Lcd_String("CLEANING",1,0);
}
DelayMs(10);
_PREVIOUS_PROCESS=_PROCESS;
}
if(_PRESSED && (_PRESSED!=_EXTRA_BUTTON))
{
Inidcate_Buzzer();
if(_PROCESS!=_Countdisplay)
{
call_control_valve();

_DISABLE_MODE=_Shortcut_Mode;
_ENABLE_MODE=_Normal_Mode;
}
if(_PROCESS!=_Cleaning && _PROCESS!=_Countdisplay)
{
Enable_Shortcut_Mode=0;
Enable_Normal_Mode=1;
}
if(_PROCESS==_Countdisplay)
{
Print_Menu();
Lcd_Cmd(0xC5); Num_Disp(count_read(mem_index1,mem_index2),5,0);
}
}
}

if(_PRESSED!=0)
{
_PRESSED=0;
_SHORTCUT_PRESSED=0;
i=0;j=0;
}
}

void change_modes()
{
switch (_DISABLE_MODE)
{
case _Normal_Mode: Enable_Normal_Mode=0;
break;
case _Password: Enable_Password=0;
break;
case _Config_Mode: Enable_Config_Mode=0;
break;
case _Valves: Enable_Valves=0;
break;
case _Selection: Enable_Selection=0;
break;
case _Coffee_Dication_Time: Enable_Coffee_Dication_Time=0;
break;
case _Tea_Dication_Time: Enable_Tea_Dication_Time=0;
break;
case _Dication_Delay: Enable_Dication_Delay=0;
break;
case _Hot_Water_Time: Enable_Hot_Water_Time=0;
break;
case _Temperature: Enable_Temperature=0;
break;
case _Cup_Count: Enable_Cup_Count=0;
break;
case _Count_Reset: Enable_Count_Reset=0;
break;
case _Shortcut_Mode: Enable_Shortcut_Mode=0;
break;
}
switch (_ENABLE_MODE)
{
case _Normal_Mode: Enable_Normal_Mode=1;
break;
case _Password: Enable_Password=1;
break;
case _Config_Mode: Enable_Config_Mode=1;
break;
case _Valves: Enable_Valves=1;
break;
case _Selection: Enable_Selection=1;
break;
case _Coffee_Dication_Time: Enable_Coffee_Dication_Time=1;
break;
case _Tea_Dication_Time: Enable_Tea_Dication_Time=1;
break;
case _Dication_Delay: Enable_Dication_Delay=1;
break;
case _Hot_Water_Time: Enable_Hot_Water_Time=1;
break;
case _Temperature: Enable_Temperature=1;
break;
case _Cup_Count: Enable_Cup_Count=1;
break;
case _Count_Reset: Enable_Count_Reset=1;
break;
case _Shortcut_Mode: Enable_Shortcut_Mode=1;
break;
}

if(Enable_Normal_Mode && (_PREVIOUS_MODE != _ENABLE_MODE))
{
Print_Name();
}
if(Enable_Password && (_PREVIOUS_MODE != _ENABLE_MODE))
{
Lcd_String("PASSWORD: ",1,0);
}
if(Enable_Valves && (_PREVIOUS_MODE != _ENABLE_MODE))
{
Lcd_String("CONFIGURE MODE",1,0);
DelayMs(100);
Lcd_String("MENU: ",1,0);
Lcd_Cmd(0x86);
Lcd_Data('1');
print_yes_no(Next);
}
if(Enable_Selection && (_PREVIOUS_MODE != _ENABLE_MODE))
{
Lcd_Cmd(0x01);
Lcd_String("SELECTION",0,0);
Lcd_String(" MODE",0,0);
DelayMs(100);
time=eeprom_read(10);
_PRESSED=_NORMAL_COFFEE_BUTTON;
Lcd_Cmd(0x01);
}
if(Enable_Coffee_Dication_Time && (_PREVIOUS_MODE != _ENABLE_MODE))
{
Lcd_String("COFFEE DICATION",1,0);
Lcd_String("TIME:",0,1);
time=eeprom_read(118);
_PRESSED=_NORMAL_TEA_BUTTON;
}
if(Enable_Tea_Dication_Time && (_PREVIOUS_MODE != _ENABLE_MODE))
{
Lcd_String("TEA DICATION",1,0);
Lcd_String("TIME:",0,1);
time=eeprom_read(119);
_PRESSED=_NORMAL_TEA_BUTTON;
}
if(Enable_Temperature && (_PREVIOUS_MODE != _ENABLE_MODE))
{
Lcd_String("TEMPERATURE",1,0);
time=eeprom_read(120);
_PRESSED=_NORMAL_TEA_BUTTON;
}
if(Enable_Dication_Delay && (_PREVIOUS_MODE != _ENABLE_MODE))
{
Lcd_String("DICATION DELAY",1,0);
Lcd_String("TIME:",0,1);
time=eeprom_read(121);
_PRESSED=_NORMAL_TEA_BUTTON;
}
if(Enable_Hot_Water_Time && (_PREVIOUS_MODE != _ENABLE_MODE))
{
Lcd_String("HOT WATER",1,0);
Lcd_String("TIME:",0,1);
time=eeprom_read(147);
_PRESSED=_NORMAL_TEA_BUTTON;
}
if(Enable_Cup_Count && (_PREVIOUS_MODE != _ENABLE_MODE))
{
Lcd_String("CUP COUNT",1,0);
Lcd_Cmd(0xC8); Num_Disp(count_read(126,127),5,0);
DelayMs(50);
}
if(Enable_Count_Reset && (_PREVIOUS_MODE != _ENABLE_MODE))
{
Lcd_String("COUNT RESET",1,0);
_PRESSED=_MILK_BUTTON;
}

_ENABLE_MODE=0;
_DISABLE_MODE=0;
_PREVIOUS_MODE=_ENABLE_MODE;
}

# 949
void call_control_valve()
{
if(Enable_Coffee_Valve)
{
_ON=_OFF=_Coffee_Valve;
control_valve(eeprom_read((12*_CHOICE_SELECTED)-2),eeprom_read((12*_CHOICE_SELECTED)-2+1));
Enable_Coffee_Valve=0;
}
if(Enable_Tea_Valve)
{
_ON=_OFF=_Tea_Valve;
control_valve(eeprom_read((12*_CHOICE_SELECTED)-2+2),eeprom_read((12*_CHOICE_SELECTED)-2+3));
Enable_Tea_Valve=0;
}
if(Enable_Mixing_Hot_Water_Valve)
{
_ON=_OFF=_Mixing_Hot_Water_Valve;
control_valve(eeprom_read((12*_CHOICE_SELECTED)-2+4),eeprom_read((12*_CHOICE_SELECTED)-2+5));
Enable_Mixing_Hot_Water_Valve=0;
}
if(Enable_Milk_Forward)
{
_ON=_OFF=_Milk_Valve_Forward;
control_valve(eeprom_read((12*_CHOICE_SELECTED)-2+6),eeprom_read((12*_CHOICE_SELECTED)-2+7));
Enable_Milk_Forward=0;
}
if(Enable_Viber_Motor)
{
_ON=_OFF=_Viber_Motor;
control_valve(eeprom_read((12*_CHOICE_SELECTED)-2+8),eeprom_read((12*_CHOICE_SELECTED)-2+9));
Enable_Viber_Motor=0;
}
if(Enable_Hot_Water_Valve)
{
_ON=_OFF=_Hot_Water_Valve;

control_valve(eeprom_read(147),2);
Enable_Hot_Water_Valve=0;
}
if(Enable_Coffee_Hot_Water_Valve)
{
_ON=_OFF=_Coffee_Hot_Water_Valve;
for(i=eeprom_read(145);i>0;i--)
{
Lcd_Cmd(0xC6);
myitoa(i,buff);
Lcd_String(buff,0,0);
eeprom_write(145,i);
control_valve(eeprom_read(118)*10,eeprom_read(121)*10);
}
Enable_Coffee_Hot_Water_Valve=0;
}
if(Enable_Tea_Hot_Water_Valve)
{
_ON=_OFF=_Tea_Hot_Water_Valve;
for(i=eeprom_read(146);i>0;i--)
{
eeprom_write(146,i);
control_valve(eeprom_read(119)*10,eeprom_read(121)*10);
}
Enable_Tea_Hot_Water_Valve=0;
}
if(Enable_Milk_Reverse)
{
_ON=_OFF=_Milk_Valve_Reverse;
control_valve(35,2);
Enable_Milk_Reverse=0;
}
if(Enable_Heater1)
{
_ON=_OFF=_Heater1;
control_valve(eeprom_read(255),eeprom_read(255));
Enable_Heater1=0;
}
}

void control_valve(unsigned int load_time, unsigned int delay_time)
{
onthevalve();

# 1031
DelayMs(load_time*100);

offthevalve();

# 1037
DelayMs(delay_time*100);
}

void onthevalve()
{
switch(_ON)
{
case _Milk_Valve_Forward:
RA2=1;
RA4=0;
break;
case _Milk_Valve_Reverse:
RA2=0;
RA4=1;
break;
case _Mixing_Hot_Water_Valve:
RA5=1;
break;
case _Hot_Water_Valve:
RC0=1;
break;
case _Coffee_Hot_Water_Valve:
RC1=1;
break;
case _Coffee_Valve:
RE0=1;
break;
case _Tea_Hot_Water_Valve:
RC2=1;
break;
case _Tea_Valve:
RE1=1;
break;
case _Viber_Motor:
RE2=1;
break;
case _Heater1:
RC3=1;
break;
}
}

void offthevalve()
{
switch(_OFF)
{
case _Milk_Valve_Forward:
RA2=0;
RA4=0;
case _Milk_Valve_Reverse:
RA2=0;
RA4=0;
break;
case _Mixing_Hot_Water_Valve:
RA5=0;
break;
case _Hot_Water_Valve:
RC0=0;
break;
case _Coffee_Hot_Water_Valve:
RC1=0;
break;
case _Coffee_Valve:
RE0=0;
break;
case _Tea_Hot_Water_Valve:
RC2=0;
break;
case _Tea_Valve:
RE1=0;
break;
case _Viber_Motor:
RE2=0;
break;
case _Heater1:
RC3=0;
break;
}
}

void count_write(unsigned char addr1,unsigned char addr2,unsigned int count)
{
if(count<=255)
{
eeprom_write(addr1,count);
}
else
{
eeprom_write(addr1,count-255);
eeprom_write(addr2,(eeprom_read(addr2)+count-255));
}
}

int count_read(unsigned char addr1, unsigned char addr2)
{
return (eeprom_read(addr2)*255)+eeprom_read(addr1);
}

void Write_ValveIn_Memory(struct item VALVE,unsigned char loc)
{
unsigned char chr=0x00;
chr=(VALVE.MIXING_HOT_WATER==1)?(chr | 0x01):(chr & 0xFE);
chr=(VALVE.MILK==1)?(chr | 0x02):(chr & 0xFD);
chr=(VALVE.COFFEE_DICATION==1)? (chr | 0x04):(chr & 0xFB);
chr=(VALVE.TEA_DICATION==1)? (chr | 0x08):(chr & 0xF7);
chr=(VALVE.VIBR_MOTOR==1)? (chr | 0x10):(chr & 0xEF);
eeprom_write(loc,chr);
}

struct item Read_ValveFrom_Memory(unsigned char MEM)
{
VALVE.MIXING_HOT_WATER= (eeprom_read(MEM)&0x01)>0?1:0;
VALVE.MILK= (eeprom_read(MEM)&0x02)>0?1:0;
VALVE.COFFEE_DICATION= (eeprom_read(MEM)&0x04)>0?1:0;
VALVE.TEA_DICATION= (eeprom_read(MEM)&0x08)>0?1:0;
VALVE.VIBR_MOTOR= (eeprom_read(MEM)&0x10)>0?1:0;
return VALVE;
}

void print_yes_no(unsigned char MEM)
{
VALVE=Read_ValveFrom_Memory(MEM);
Lcd_Cmd(0xC3);
if( VALVE.COFFEE_DICATION )
{
Lcd_Data('Y');;
}
else
Lcd_Data('N');;
Lcd_Cmd(0xC5);
if( VALVE.TEA_DICATION )
{
Lcd_Data('Y');;
}
else
Lcd_Data('N');;
Lcd_Cmd(0xC7);
if( VALVE.MIXING_HOT_WATER )
{
Lcd_Data('Y');;
}
else
Lcd_Data('N');;
Lcd_Cmd(0xC9);
if( VALVE.MILK )
{
Lcd_Data('Y');;
}
else
Lcd_Data('N');;
Lcd_Cmd(0xCB);
if( VALVE.VIBR_MOTOR)
{
Lcd_Data('Y');;
}
else
Lcd_Data('N');;
Lcd_Cmd(0xCD);
}
